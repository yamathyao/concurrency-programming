##### 51、怎么检测一个线程是否拥有锁？

>在java.lang.Thread中有一个方法叫holdsLock()，它返回true则当且仅当当前线程拥有某个具体对象的锁。

##### 52、你如何在Java中获取线程堆栈？

>I.kill -3 [java pid]
>
>不会在当前终端输出，它会输出到代码执行的或指定的地方去。比如，kill -3 tomcat pid, 输出堆栈到log目录下。
>
>II.Jstack [java pid]
>
>这个比较简单，在当前终端显示，也可以重定向到指定文件中。
>
>III.JvisualVM：Thread Dump
>
>不做说明，打开JvisualVM后，都是界面操作，过程还是很简单的。

##### 53、JVM中哪个参数是用来控制线程的栈堆栈小的?

>-Xss 每个线程的栈大小

##### 54、Thread类中的yield方法有什么作用？

>使当前线程从执行状态（运行状态）变为可执行态（就绪状态）。
>
>当前线程到了就绪状态，那么接下来哪个线程会从就绪状态变成执行状态呢？可能是当前线程，也可能是其他线程，看系统的分配了。

##### 55、Java中ConcurrentHashMap的并发度是什么？

>ConcurrentHashMap把实际map划分成若干部分来实现它的可扩展性和线程安全。这种划分是使用并发度获得的，它是ConcurrentHashMap类构造函数的一个可选参数，默认值为16，这样在多线程情况下就能避免争用。
>
>在JDK8后，它摒弃了Segment（锁段）的概念，而是启用了一种全新的方式实现,利用CAS算法。同时加入了更多的辅助变量来提高并发度，具体内容还是查看源码吧。

##### 56、Java中Semaphore是什么？

>Java中的Semaphore是一种新的同步类，它是一个计数信号。从概念上讲，从概念上讲，信号量维护了一个许可集合。如有必要，在许可可用前会阻塞每一个 acquire()，然后再获取该许可。每个 release()添加一个许可，从而可能释放一个正在阻塞的获取者。但是，不使用实际的许可对象，Semaphore只对可用许可的号码进行计数，并采取相应的行动。信号量常常用于多线程的代码中，比如数据库连接池。

##### 57、Java线程池中submit() 和 execute()方法有什么区别？

>两个方法都可以向线程池提交任务，execute()方法的返回类型是void，它定义在Executor接口中。
>
>而submit()方法可以返回持有计算结果的Future对象，它定义在ExecutorService接口中，它扩展了Executor接口，其它线程池类像ThreadPoolExecutor和ScheduledThreadPoolExecutor都有这些方法。

##### 58、什么是阻塞式方法？

>阻塞式方法是指程序会一直等待该方法完成期间不做其他事情，ServerSocket的accept()方法就是一直等待客户端连接。这里的阻塞是指调用结果返回之前，当前线程会被挂起，直到得到结果之后才会返回。此外，还有异步和非阻塞式方法在任务完成前就返回。

##### 59、Java中的ReadWriteLock是什么？

>读写锁是用来提升并发程序性能的锁分离技术的成果。

##### 60、volatile 变量和 atomic 变量有什么不同？

>Volatile变量可以确保先行关系，即写操作会发生在后续的读操作之前, 但它并不能保证原子性。例如用volatile修饰count变量那么 count++ 操作就不是原子性的。
>
>而AtomicInteger类提供的atomic方法可以让这种操作具有原子性如getAndIncrement()方法会原子性的进行增量操作把当前值加一，其它数据类型和引用变量也可以进行相似操作。
